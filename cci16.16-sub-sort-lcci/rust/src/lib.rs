struct Solution;
impl Solution {
    pub fn sub_sort(array: Vec<i32>) -> Vec<i32> {
        // 如果数组为空，或者数组没有元素、或者数组只有一个元素，找不出符合要求的序列，根据题目要求返回 [-1,-1]
        if array.is_empty() || array.len() == 1 {
            return vec![-1,-1];
        }
        // 正常来说，整个数组是递增有序的，比如 1 3 5 9 10 这种
        // 如果某个元素的左边存在比它更大的元素，比如 1 10 5
        // 5 这个元素的左边存在 10 这个元素比它更大，所以 5 一定要参与到排序里去的

        // 如果某个元素的右边存在比它更小的元素，比如 1 10 5
        // 10 这个元素的右边存在 5 这个元素比它更小，所以 10 一定要参与到排序里去的

        // 所以我们只需要寻找最靠右的那个数（满足左边存在大于它的数）
        // 和最靠左的那个数（满足右边存在比小于它的数）
        // 那么这两个数之间就是要排序的区间了

        // 第一次遍历时从尾到头进行遍历，目的是为了找出最靠左的那个数，即满足右边小于它的数

        // 一开始默认最右边的数为最小值
        let mut min = array[array.len() -1];
        // 默认找不到的情况下 m 为 -1
        let mut m = -1;
        // 从尾到头进行遍历，直到遍历到数组的开始位置
        for j in (0..array.len()-1).rev() {
            // 获取当前遍历的元素值
            let cur = array[j];
            // 如果此时当前的元素值小于等于最小值，需要更新最小值
            if cur <= min {
                // 更新最小值
                min = cur;
            } else {
                // 如果当前元素大于了最小值，由于我们是从尾到头进行遍历，说明当前元素的右边存在小于它的数，这个元素需要加入到排序的区间
                // 比如 10 9 7
                // 最小值是 7, 而 9 大于 7，所以 9 需要加入到排序的区间
                // 因此更新 m 的值为 j，说明此时遍历的那些元素中 j 是最靠左的那个数
                m = j as i32;
            }
        }

        // 第二次遍历时从头到尾进行遍历，目的是为了找到最靠右的那个数，即满足左边存在大于它的数
        // 一开始默认最左边的数为最大值
        let mut max = array[0];
        // 默认找不到的情况下 n 为 -1
        let mut n = -1;
        // 从头进行遍历，直到遍历到数组的结束位置
        for i in 1..array.len() {
            // 获取当前遍历的元素值
            let cur = array[i];
            // 如果此时当前的元素值大于等于最大值，需要更新最大值
            if cur >= max {
                // 更新最大值
                max = cur;
            } else {
                // 如果当前元素小于最大值，由于我们是从头到尾进行遍历，说明当前元素的左边存在大于它的数，这个元素需要加入到排序的区间
                // 比如 10 9 7
                // 最小值是 10，而 7 小于 10，所以 7 需要加入到排序的区间
                // 因此更新 n 的值为 i，说明此时遍历的那些元素中 i 是最靠右的那个数
                n = i as i32;
            }
        }

        // m 和 n 这两个数之间就是要排序的区间，返回即可
        return vec![m, n];
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sub_sort() {
        let vec = Solution::sub_sort(vec![1,2,4,7,10,11,7,12,6,7,16,18,19]);
        assert_eq!(vec, vec![3, 9]);

        let vec = Solution::sub_sort(vec![1,3,5,10,6,11,4,13,15,19]);
        assert_eq!(vec, vec![2, 6]);

        let vec = Solution::sub_sort(vec![1,3,5,7,9]);
        assert_eq!(vec, vec![-1, -1]);
    }
}
